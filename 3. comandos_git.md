<h1>
    <span> Versionamento de Código com Git e GitHub</span>
</h1>

## Criando e Clonando Repositórios
Existem duas formas de obter um repositório Git na sua máquina:
1. Transformando um diretório local que não está sob controle de versão, num repositório Git;
2. Clonando um repositório Git existente.

### Criando um Repositório Local
Acesse a pasta que deseja transformar em um repositório Git pelo terminal ou clique no atalho em “Git Bash Here”:
1. Inicialize um repositório Git no diretório escolhido:
    ```bash
    $ git init
    ```
2. Conecte o repositório local com o repositório remoto:
    ```bash
    $ git remote add origin https://github.com/username/nome-do-repositorio.git
    ```
3. Exibindo se estamos conectados à algum repositório local com o repositório remoto:
    ```bash
    $ git remote -v
    ```
### Clonando um Repositório Remoto
Acesse o diretório no qual deseja salvar o repositório remoto do GitHub e clique no atalho em “Git Bash Here”:
1. Clone o repositório para o diretório selecionado
    ```bash
        $ git clone https://github.com/username/nome-do-repositorio.git
    ```
2. Clone o repositório para o diretório selecionado com nome diferente do repositório original:
   ```bash
        $ git clone https://github.com/username/nome-do-repositorio.git nome-do-repositório-local
    ```
##

## Gravando Alterações em Seu Repositório local
### Verificando os status de seus arquivos
A principal ferramenta que você vai usar para determinar quais arquivos estão em qual estado é o comando `git status`.
```bash
$ git status
```

O ciclo de vida dos status de seus arquivos

<img align="center" src="images/lifecycle.png"></a>

Lembre-se que cada arquivo em seu diretório de trabalho pode estar em um dos seguintes estados: rastreado e não-rastreado.
- **Arquivos Rastreados:** Arquivos rastreados são arquivos que foram incluídos no último snapshot, eles podem ser:
  - Não modificados
  - Modificados
  - Preparados (adicionados ao STAGE com o comando `git add`)
 
- **Arquivos Não-Rastreados (Untracked):** quaisquer arquivos em seu diretório de trabalho que não foram incluídos em seu último snapshot e não estão na área de preparação (stage).

Assim que você edita alguns arquivos, Git os considera modificados, porque você os editou desde o seu último commit. Você prepara os arquivos editados e então faz commit das suas alterações, e o ciclo se repete. 

### Rastreando arquivos novos
Para começar a rastrear um novo arquivo, você deve usar o comando `git add`. Para começar a rastrear o arquivo `lifecycle.png` dentro do diretório `images`, você deve executar o seguinte:
```bash
$ git add images/lifecycle.png
```

Executando o comando status novamente, você pode ver que seu `lifecycle.png` agora está sendo rastreado e preparado (staged) para o commit:
```bash
$ git status
On branch main
Your branch is up to date with 'origin/main'.

Changes to be committed:
  (use "git restore --staged <file>..." to unstage)
        new file:   images/lifecycle.png
```

É possível saber que o arquivo está preparado porque ele aparece sob o título “Changes to be committed”.

### Rastreando arquivos modificados
Se você modificar o arquivo `README.md`, que já era rastreado, e então executar git status novamente, você deve ver algo como:
```
$ git status
On branch main
Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git restore <file>..." to discard changes in working directory)
        modified:   README.md

no changes added to commit (use "git add" and/or "git commit -a")
```

O arquivo `README.md` aparece sob a seção “Changes not staged for commit” — que indica que um arquivo rastreado foi modificado no diretório de trabalho mas ainda não foi mandado para o stage (preparado). Para mandá-lo para o stage, você precisa executar o comando `git add`. Vamos executar git add agora, para mandar o arquivo `README.md` para o stage, e então executar `git status` novamente:

```
$ git status
On branch main
Changes to be committed:
  (use "git restore --staged <file>..." to unstage)
        modified:   README.md

```

O arquivo está preparado (no stage) e entrará no seu próximo commit. Neste momento, suponha que você se lembre de uma pequena mudança que quer fazer no arquivo README.md antes de fazer o commit. Você abre o arquivo, faz a mudança e está pronto para fazer o commit. No entanto, vamos executar `git status` mais uma vez:

```
$ git status
On branch main
Changes to be committed:
  (use "git restore --staged <file>..." to unstage)
        modified:   README.md

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git restore <file>..." to discard changes in working directory)
        modified:   README.md
```

Agora o `README.md` está listado como preparado (staged) e também como não-preparado (unstaged). Acontece que o Git põe um arquivo no stage exatamente como ele está no momento em que você executa o comando `git add`. Se você executar `git commit` agora, a versão do `README.md` que vai para o repositório é aquela de quando você executou `git add`, não a versão que está no seu diretório de trabalho. Se você modificar um arquivo depois de executar `git add`, você tem que executar `git add` de novo para por sua versão mais recente no stage:

```
$ git add README.md
$ git status
On branch main
Changes to be committed:
  (use "git restore --staged <file>..." to unstage)
        modified:   README.md
```
### Git Add
O `git add` é um comando de múltiplos propósitos:
- Serve para começar a rastrear arquivos;
- Serve para colocar arquivos modificados no stage (Preparação);
- Serve para marcar arquivos que estão em conflito de mesclagem como resolvidos;
- Pode ser útil pensar nesse comando mais como “adicione este conteúdo ao próximo commit”.

Para adicionar um arquivo específico para o stage, execute o comando abaixo:
```
git add nome_do_arquivo
```

Para adicionar vários arquivos de uma vez para o stage, execute o comando abaixo:
```
git add .
```
### Ignorando Arquivos
Frequentemente você terá uma classe de arquivos que não quer que sejam adicionados automaticamente pelo Git e nem mesmo que ele os mostre como não-rastreados. Geralmente, esses arquivos são gerados automaticamente, tais como arquivos de log ou arquivos produzidos pelo seu sistema de compilação (build). Nesses casos, você pode criar um arquivo chamado `.gitignore`, contendo uma lista de padrões de nomes de arquivo que devem ser ignorados. Aqui está um exemplo de arquivo `.gitignore`:

```
$ cat .gitignore
*.[oa]
*~
```
A primeira linha diz ao Git para ignorar todos os arquivos que terminem com `“.o” ou “.a”` – arquivos objeto ou de arquivamento, que podem ser produtos do processo de compilação. A segunda linha diz ao Git para ignorar todos os arquivos cujo nome termine com um til (~), que é usado por muitos editores de texto, como o Emacs, para marcar arquivos temporários. Você também pode incluir diretórios `log, tmp ou pid`; documentação gerada automaticamente; e assim por diante. Configurar um arquivo `.gitignore`, antes de você começar um repositório, geralmente é uma boa ideia para que você não inclua acidentalmente em seu repositório Git arquivos que você não quer.
As regras para os padrões que podem ser usados no arquivo .gitignore são as seguintes:
- Linhas em branco ou começando com # são ignoradas;
- Os padrões que normalmente são usados para nomes de arquivos funcionam.
- Você pode iniciar padrões com uma barra (/) para evitar recursividade.
- Você pode terminar padrões com uma barra (/) para especificar um diretório.
- Você pode negar um padrão ao fazê-lo iniciar com um ponto de exclamação (!).
  
Aqui está outro exemplo de arquivo .gitignore:

```
# ignorar arquivos com extensão .a
*.a

# mas rastrear o arquivo lib.a, mesmo que você esteja ignorando os arquivos .a acima
!lib.a

# ignorar o arquivo TODO apenas no diretório atual, mas não em subdir/TODO
/TODO

# ignorar todos os arquivos no diretório build/
build/

# ignorar doc/notes.txt, mas não doc/server/arch.txt
doc/*.txt

# ignorar todos os arquivos .pdf no diretório doc/
doc/**/*.pdf
```
O GitHub mantém uma lista bem abrangente com bons exemplos de arquivo `.gitignore` para vários projetos e linguagens
<a href="https://github.com/github/gitignore">clique aqui para saber mais</a>

##

## Comandos de Exibição
A principal ferramenta que você vai usar para determinar quais arquivos estão em qual estado é o comando `git status`.
```bash
$ git status
```
Para verificar o status de seus arquivos de forma resumida ou mais verbosa execute o comando `git status -s` ou `git status --short`
```
$ git status -s
```
Se o comando `git status` for vago demais para você — você quer saber exatamente o que você alterou, não apenas quais arquivos foram alterados — você pode usar o comando `git diff`. O `git diff` exibe exatamente as linhas que foram adicionadas e removidas:
```
$ git diff README.md
warning: in the working copy of 'README.md', LF will be replaced by CRLF the next time Git touches it
diff --git a/README.md b/README.md
index a64e082..174abda 100644
--- a/README.md
+++ b/README.md
@@ -1 +1,2 @@
 fazendo alteração no documento. mais uma alteração. Testando alteração após o git add.
+Adicionando uma nova linha.
```
O comando acima compara o que está no seu `diretório de trabalho` com o que está no `stage`. O resultado permite que você saiba quais alterações você fez que ainda não foram mandadas para o `stage`.

Se você quiser ver as alterações que você mandou para o stage e que entrarão no seu próximo commit, você pode usar `git diff --staged`. Este comando compara as alterações que estão no seu `stage` com o seu último `commit`:
```
$ git diff --staged
diff --git a/README.md b/README.md
index 8d8ddcf..174abda 100644
--- a/README.md
+++ b/README.md
@@ -1 +1,2 @@
-fazendo alteração no documento.
+fazendo alteração no documento. mais uma alteração. Testando alteração após o git add.
+Adicionando uma nova linha.
```

Para ver todo o histórico de `commits` realizados em um repositório execute o comando `git log`. Observe que as informações do autor, e-mail, data e mensagem do commit aparecem nesse comando:
```
$ git log
commit ee8e823f90756d10d9c1a6f1c4a2dd41162c30c7 (HEAD -> main)
Author: eldhersa <eldher.sa.2015@gmail.com>
Date:   Thu May 16 15:46:40 2024 -0300

    Adicionando uma nova alteração no README.md

commit 90adb1f5b83f746d661a3f1a7d12cd5668b09dff
Author: eldhersa <eldher.sa.2015@gmail.com>
Date:   Tue May 14 14:42:17 2024 -0300

    Alteração no readme
```

##

## Fazendo Commit
Agora que sua área de stage está preparada do jeito que você quer, você pode fazer commit das suas alterações. Lembre-se que qualquer coisa que ainda não foi enviada para o stage — qualquer arquivo que você tenha criado ou alterado e que ainda não tenha sido adicionado com git add — não entrará nesse commit.
Para fazer um `commit` você pode digitar sua mensagem de commit diretamente na linha de comando, depois da opção -m do comando commit, assim:
```
$ git commit -m "Aqui você digitar uma mensagem de exibição mostrando que alterações foram feitas desde o último commit"
```

##

## Desfazendo Alterações no Repositório Local
### Para desfazer o versionamento iniciado pelo `git init`, basta apagar o diretório `.git/` de dentro do diretório do repositório:
```
$ rm -rf .git
``` 
### Como alterar a mensagem do último commit
```bash
$ git commit --amend
```

Alterando a mensagem sem abrir o editor:  
```bash
$ git commit --amend –m"nova mensagem"
```

### Como desfazer um commit
```bash
$ git reset
```
```bash
$ git reset --soft
```
```bash
$ git reset --mixed
```
```bash
$ git reset --hard
```
